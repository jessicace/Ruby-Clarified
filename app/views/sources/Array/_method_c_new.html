<section id="method-c-new" class="method-detail ">
		
    	
				<div class="method-heading">
    			<span class="method-callseq">
						new(size=0, default=nil)
          </span>

					
						<span class="method-click-advice">click to toggle source</span>
					
        </div>
			
				<div class="method-heading">
    			<span class="method-callseq">
						new(array)
          </span>

					
        </div>
			
				<div class="method-heading">
    			<span class="method-callseq">
						new(size) {|index| block }
          </span>

					
        </div>
			
		
		
		<div class="method-description">
			
    		<p>Returns a new array.</p>

<p>In the first form, if no arguments are sent, the new array will be empty.
When a <code>size</code> and an optional <code>default</code> are sent, an
array is created with <code>size</code> copies of <code>default</code>. 
Take notice that all elements will reference the same object
<code>default</code>.</p>

<p>The second form creates a copy of the array passed as a parameter (the
array is generated by calling <a
href="Array.html#method-i-to_ary">#to_ary</a> on the parameter).</p>

<pre class="ruby"><span class="ruby-identifier">first_array</span> = [<span class="ruby-string">&quot;Matz&quot;</span>, <span class="ruby-string">&quot;Guido&quot;</span>]

<span class="ruby-identifier">second_array</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">first_array</span>) <span class="ruby-comment">#=&gt; [&quot;Matz&quot;, &quot;Guido&quot;]</span>

<span class="ruby-identifier">first_array</span>.<span class="ruby-identifier">equal?</span> <span class="ruby-identifier">second_array</span>       <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>In the last form, an array of the given size is created.  Each element in
this array is created by passing the element&#39;s index to the given block
and storing the return value.</p>

<pre class="ruby"><span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">3</span>){ <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">**</span> <span class="ruby-value">2</span> }
<span class="ruby-comment"># =&gt; [0, 1, 4]</span>
</pre>

<h2 id="method-c-new-label-Common+gotchas">Common gotchas<span><a href="#method-c-new-label-Common+gotchas">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>When sending the second parameter, the same object will be used as the
value for all the array elements:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>, <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span>)
<span class="ruby-comment"># =&gt; [{}, {}]</span>

<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>][<span class="ruby-string">&#39;cat&#39;</span>] = <span class="ruby-string">&#39;feline&#39;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [{&quot;cat&quot;=&gt;&quot;feline&quot;}, {&quot;cat&quot;=&gt;&quot;feline&quot;}]</span>

<span class="ruby-identifier">a</span>[<span class="ruby-value">1</span>][<span class="ruby-string">&#39;cat&#39;</span>] = <span class="ruby-string">&#39;Felix&#39;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [{&quot;cat&quot;=&gt;&quot;Felix&quot;}, {&quot;cat&quot;=&gt;&quot;Felix&quot;}]</span>
</pre>

<p>Since all the <a href="Array.html">Array</a> elements store the same hash,
changes to one of them will affect them all.</p>

<p>If multiple copies are what you want, you should use the block version
which uses the result of that block each time an element of the array needs
to be initialized:</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-constant">Array</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2</span>) { <span class="ruby-constant">Hash</span>.<span class="ruby-identifier">new</span> }
<span class="ruby-identifier">a</span>[<span class="ruby-value">0</span>][<span class="ruby-string">&#39;cat&#39;</span>] = <span class="ruby-string">&#39;feline&#39;</span>
<span class="ruby-identifier">a</span> <span class="ruby-comment"># =&gt; [{&quot;cat&quot;=&gt;&quot;feline&quot;}, {}]</span>
</pre>
      

			
					
			
      	<div class="method-source-code" id="new-source">
     			<pre>static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
        if (ARY_OWNS_HEAP_P(ary) &amp;&amp; RARRAY_CONST_PTR(ary) != 0) {
            ruby_sized_xfree((void *)RARRAY_CONST_PTR(ary), ARY_HEAP_SIZE(ary));
        }
        rb_ary_unshare_safe(ary);
        FL_SET_EMBED(ary);
        ARY_SET_EMBED_LEN(ary, 0);
        if (rb_block_given_p()) {
            rb_warning(&quot;given block not used&quot;);
        }
        return ary;
    }
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    /* NUM2LONG() may call size.to_int, ary can be frozen, modified, etc */
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    /* recheck after argument conversion */
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn(&quot;block supersedes default value argument&quot;);
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            ARY_SET_LEN(ary, i + 1);
        }
    }
    else {
        ary_memfill(ary, 0, len, val);
        ARY_SET_LEN(ary, len);
    }
    return ary;
}</pre>
    		</div>
      
		</div>
</section>
