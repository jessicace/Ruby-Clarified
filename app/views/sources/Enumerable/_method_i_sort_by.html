<section id="method-i-sort_by" class="method-detail ">
		
    	
				<div class="method-heading">
    			<span class="method-callseq">
						sort_by { |obj| block }   &rarr; array
          </span>

					
						<span class="method-click-advice">click to toggle source</span>
					
        </div>
			
				<div class="method-heading">
    			<span class="method-callseq">
						sort_by                   &rarr; an_enumerator
          </span>

					
        </div>
			
		
		
		<div class="method-description">
			<div class="method-group">
				<h3 class="method-group-label">Description</h3>
				<div class="method-group-content">
    			<p>Sorts <em>enum</em> using a set of keys generated by mapping the values in
						<em>enum</em> through the given block.</p>
					<p>One value is passed into the block.</p>

<pre class="ruby"><span class="ruby-identifier">new_list</span> = <span class="ruby-identifier">old_list</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">file</span><span class="ruby-operator">|</span> <span class="ruby-identifier">file</span>.<span class="ruby-identifier">mtime</span> }
</pre>

<p>If no block is given, an enumerator is returned instead.</p>
				</div>
			</div>

			<div class="method-group">
				<h3 class="method-group-label">Examples</h3>
				<div class="method-group-content">
					<h3 id="method-i-sort_by-label-Example">Example<span><a href="#method-i-sort_by-label-Example">&para;</a> <a href="#top">&uarr;</a></span></h3>
					<pre class="ruby"><span class="ruby-node">%w{apple pear fig}</span>.<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">word</span><span class="ruby-operator">|</span> <span class="ruby-identifier">word</span>.<span class="ruby-identifier">length</span>}
<span class="ruby-comment"># =&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]</span>
					</pre>

					<p>As of Ruby 1.8, the method <code>Enumerable#sort_by</code> implements a
						built-in Schwartzian Transform, useful when key computation or comparison
						is expensive. Note that this is not a full implementation of the
						Schwartzian Transform.</p>

					<p>The current implementation of <code>sort_by</code> generates an array of
						tuples containing the original collection element and the mapped value.
						This makes <code>sort_by</code> fairly expensive when the keysets are
						simple.</p>

					<p>Sort_by caches the sort keys before the sort-  values are stored as
						key-value pairs in a temporary array.  The first item in each sub-array is
						used for sorting the array initially. The array is subsequently flattened
						into a one-dimensional array. Perl users often call this approach a
						Schwartzian Transform, after Randal Schwartz. We construct a temporary
						array, where each element is an array containing our sort key, along with
						the filename. We sort this array, and then extract the filename from the
						result.</p>

					<p>This is exactly what <code>sort_by</code> does internally.</p>

					<pre class="ruby">
						<span class="ruby-identifier">sorted</span> =
						<span class="ruby-constant">Dir</span>[<span class="ruby-string">&quot;*&quot;</span>].<span class="ruby-identifier">sort_by</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">f</span><span class="ruby-operator">|</span> <span class="ruby-identifier">test</span>(<span class="ruby-value">?M</span>, <span class="ruby-identifier">f</span>) }
						<span class="ruby-identifier">sorted</span> 
						<span class="ruby-comment"># =&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</span>
					</pre>

					<p>Because of this implementation,
						<a href="Enumerable.html#method-i-sort_by">#sort_by</a> is faster when used
						for large datasets.</p>

					<p>This is not considered a full implementation of the Schwartzian Transform,
						however. This is because it fixes the comparison of the memoized keys.  A
						full Schwartzian Transform also details how the memoized keys are compared.
						It uses lazy logic - if the distinction between the primary keys is
						sufficient,  it will subsequently avoid comparisons in secondary and
						tertiary keys.</p>

				</div>
			</div>
      

			
					
			
      	<div class="method-source-code" id="sort_by-source">
     			<pre>static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary, buf;
    struct MEMO *memo;
    long i;
    struct sort_by_data *data;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    if (RB_TYPE_P(obj, T_ARRAY) &amp;&amp; RARRAY_LEN(obj) &lt;= LONG_MAX/2) {
        ary = rb_ary_new2(RARRAY_LEN(obj)*2);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC_CLEAR_CLASS(ary);
    buf = rb_ary_tmp_new(SORT_BY_BUFSIZE*2);
    rb_ary_store(buf, SORT_BY_BUFSIZE*2-1, Qnil);
    memo = MEMO_NEW(0, 0, 0);
    OBJ_INFECT(memo, obj);
    data = (struct sort_by_data *)&amp;memo-&gt;v1;
    RB_OBJ_WRITE(memo, &amp;data-&gt;ary, ary);
    RB_OBJ_WRITE(memo, &amp;data-&gt;buf, buf);
    data-&gt;n = 0;
    rb_block_call(obj, id_each, 0, 0, sort_by_i, (VALUE)memo);
    ary = data-&gt;ary;
    buf = data-&gt;buf;
    if (data-&gt;n) {
        rb_ary_resize(buf, data-&gt;n*2);
        rb_ary_concat(ary, buf);
    }
    if (RARRAY_LEN(ary) &gt; 2) {
        RARRAY_PTR_USE(ary, ptr,
                      ruby_qsort(ptr, RARRAY_LEN(ary)/2, 2*sizeof(VALUE),
                                 sort_by_cmp, (void *)ary));
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=1; i&lt;RARRAY_LEN(ary); i+=2) {
        RARRAY_ASET(ary, i/2, RARRAY_AREF(ary, i));
    }
    rb_ary_resize(ary, RARRAY_LEN(ary)/2);
    RBASIC_SET_CLASS_RAW(ary, rb_cArray);
    OBJ_INFECT(ary, memo);

    return ary;
}</pre>
    		</div>
      
		</div>
</section>
